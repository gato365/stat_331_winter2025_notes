---
title: "ETV - Task - Who is the real GOAT of all time in the NBA (Part 2)"
format: html
editor: visual
---

### Description

MJ, LJ, and KB are often regarded as the three most popular players in NBA history, each celebrated for their unique contributions to the game. However, who truly holds the title of the GOAT (Greatest of All Time)? In this task, we will focus specifically on MJ and examine his performance across different divisions during the three stages of his career—Early Career, Intermediate, and Veteran. By analyzing his first 15 seasons, we aim to uncover patterns and trends that highlight his strengths and challenges throughout his career. This analysis will also help us understand how his performance varied by division and stage, offering insights into his dominance in specific matchups.

**Background Information:**

This datas et was originally extracted in 2019 as part of a research project. Since the data was sourced from an HTML webpage, it underwent extensive cleaning to prepare it for analysis. In this class, we will use MJ's data set to explore and apply various ETV (Extraction, Transformation, Visualization) methods, while gaining practical skills for working with real-world data.

**Sub Task 1: Create Stage Variable**

Create a new variable, Stage, that categorizes MJ's career into three distinct phases based on his playing seasons. The first five seasons (1–5) are labeled as "Early Career," the next five seasons (6–10) are categorized as "Intermediate," and the final five seasons (11–15) are labeled as "Veteran." This grouping allows for a clear analysis of MJ's performance trends and evolution throughout his career, making it easier to compare his contributions during different stages of his playing years.

------------------------------------------------------------------------

**Sub Task 2: Create a Summary Table**

To analyze MJ's performance across divisions and stages of his career effectively, create a summary table that calculates his average points (`PTS`), total rebounds (`TRB`), and assists (`AST`) for each division during different stages of his career. Then, group the data by division and stage. Use `summarise` to calculate the average performance metrics for each combination of division and stage. Finally, restructure the table using `pivot_longer`. By organizing the performance metrics (`PTS`, `TRB`, `AST`) into a single column, the table becomes more flexible for detailed analysis, easier to filter or focus on specific metrics, and ideal for creating visualizations that compare trends across divisions and stages. This format simplifies identifying patterns and highlights differences in performance over time.

------------------------------------------------------------------------

**Sub Task 3: Create Visualization of Minutes vs Points**

Explore MJ's performance trends across the three career stages—Early Career, Intermediate, and Veteran—by focusing on his scoring (`PTS`) and minutes played (`MP`). Specifically, identify the division within each stage where MJ scored the highest total points. After determining the divisions with peak scoring performances, examine the relationship between `PTS` and `MP` for games played in these divisions during the respective stages. This analysis highlights patterns in MJ's workload and scoring efficiency and provides insights into divisions where he consistently excelled. Consider the competitiveness of the divisions and notable match-ups during these peak performances. The final visualization provides a detailed comparison of `PTS` and `MP` across these divisions and career stages, showcasing how MJ's role and performance evolved over time.

------------------------------------------------------------------------

**Data Ethics:** The data used in this project was scraped from the Sports Reference website, a publicly accessible resource. This data is harmless in its intended use, focusing solely on historical player statistics for educational purposes in data analysis and visualization. However, data ethics should still be considered. For instance, while this data is not sensitive, ensuring proper attribution to the data source is essential to respect intellectual property.

Additionally, when working with data in general, it is important to avoid misrepresentation, maintain transparency about data collection methods, and consider privacy and consent, especially when analyzing personal or sensitive information. Ethical practices ensure that the data is used responsibly and for its intended purpose.

### Load Libraries(Empty)

**Q1.** Install the `tidyr` package.

```{r}
## Install required packages
```



```{r}
## Enter Libraries

```



### Extraction

**Q2.** Define the path to the `nba_goats.xlsx` file. Ensure the correct path to the file is assigned. Extract only the "MJ" (save as `mj_df`) and "divisions" (save as `div_df`) sheets from the `nba_goats.xlsx` file into RStudio. Use the provided code to specify the file path and read the sheets into separate data frames.



```{r}
## Specify Path
```

```{r}
## Read in Sheets
```

### Transformation

We want to do two things:

1.  Merge the `mj_df` and `div_df` data frames to be able to compare divisions that he played against to see which divisions he performed well against.

2.  Pivot the `mj_df` into a format enables a detailed comparison of trends in points, rebounds, and assists over MJ's 15 seasons. This allows you to visualize how his performance evolved in each category, identify patterns or shifts in his game, and highlight seasons where he excelled in specific aspects such as scoring, rebounding, or play making.

#### Learning Moment 1 - Joins (A digression)

Creation of sample data frames for the following examples:



```{r}
# # Sample Data Frame 1
# names_df <- ___________(
#   ID = c(1, 2, 3, 4),
#   Name = c("Alice", "Bob", "Charlie", "David")
# )
# 
# # Sample Data Frame 2
# scores_df <- ___________(
#   ID = c(3, 4, 5, 6),
#   Score = c(85, 90, 78, 88)
# )
```

##### Inner Join



```{r}
# inner_join_df <- _____________(names_df, scores_df, by = _________)
# print( _____________)
```

**Q3.** What is the purpose of the `inner_join` function?

\[Place Solution - Begin\]


\[Place Solution - End\]

**Q4.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/inner-join.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

------------------------------------------------------------------------

##### Left Join/Right Join



```{r}
# left_join_df <- names_df %>% 
#   ___________(scores_df, ___________)
# 
# print( _____________)
```

**Q5.** What is the purpose of the `left_join` function?

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q6.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/left-join.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q7.** Modify the code to perform a right join, ensuring the resulting data matches the structure and logic of the previous left join. Name this data frame `right_join_df`.


```{r}
## Create the Right Join
```

###### Checking if Data Frames are equivalent

**Checking Data Frame Equivalence After Joins**

When performing data manipulations such as joins, it's important to ensure that the resulting data frames are equivalent if they are expected to produce the same output. This demonstration shows how to check for equivalence between two data frames (`left_join_df` and `right_join_df`) that have undergone different join operations.

1.  **Sorting for Consistency**: Before comparing, the data frames are arranged by a common key column (e.g., `ID`). Sorting ensures that the rows in both data frames are in the same order, eliminating discrepancies caused by different row arrangements.

2.  **Using `all_equal` for Comparison**: The `all_equal` function checks for structural and content equivalence between the two sorted data frames. This comparison accounts for column names, data types, and values, providing a comprehensive check for equivalence.

3.  **Output Interpretation**: The result of `all_equal` is logical:

    -   **TRUE**: The data frames are identical in structure and content.
    -   **FALSE**: The data frames differ, indicating discrepancies in rows, columns, or values.

This technique is especially useful in validating your data processing steps and ensuring that left and right joins produce consistent and accurate results when applied to similar datasets.

```{r}
# Arrange both data frames by a common key column (e.g., "ID") to ensure consistent order
left_join_df_sorted <- left_join_df %>% arrange(ID)
right_join_df_sorted <- right_join_df %>% arrange(ID)

# Use all.equal to compare after arranging
identical_data <- all_equal(left_join_df_sorted, right_join_df_sorted)

# Print result
identical_data
```

##### Full Join


```{r}
# full_join_df <- _______(names_df, _______, _______)
# print(_______)
```

**Q8.** What is the purpose of the `full_join` function?

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q9.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/full-join.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

##### Semi Join (Not in SQL)


```{r}
# semi_join_df <- ______(______, ______, ______)
# print(______)
```

**Q10.** What is the purpose of the `semi_join` function?

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q11.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/semi-join.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

##### Anti Join (Not in SQL)



```{r}
# anti_join_df 
```

**Q12.** What is the purpose of the `anti_join` function?

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q13.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/anti-join.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

Here are real-life examples for each type of join and when you might want to use them instead of the others:

------------------------------------------------------------------------

Think through these..

**1. Inner Join**

-   **Scenario**: Combining customer orders and product details to generate an invoice.

-   **Why Use It?**: You only want rows where there is a match in both data frames (e.g., customers with valid orders and products that exist in inventory).

-   **Example**:

-   *Left Table*: Customer orders with product IDs.

-   *Right Table*: Product details with prices.

-   *Result*: Only orders with matching product IDs will appear in the result.

------------------------------------------------------------------------

**2. Left Join**

-   **Scenario**: Adding customer demographic information to sales records.

-   **Why Use It?**: You want all sales records, even if some customers do not have demographic data available.

-   **Example**:

-   *Left Table*: Sales records with customer IDs.

-   *Right Table*: Customer demographics (e.g., age, gender).

-   *Result*: All sales records are retained, with demographic data added where available. Missing demographics appear as `NA`.

------------------------------------------------------------------------

**3. Right Join**

-   **Scenario**: Finding which registered courses are missing enrollments.

-   **Why Use It?**: You want all rows from the second data frame, even if they don’t match the first.

-   **Example**:

-   *Left Table*: Student enrollments with course IDs.

-   *Right Table*: All available courses.

-   *Result*: All courses are shown, with enrollment data included where available. Courses with no enrollments appear as `NA`.

------------------------------------------------------------------------

**4. Full Join**

-   **Scenario**: Merging attendance data from two separate schools to find total attendance across both schools.

-   **Why Use It?**: You want to combine all rows from both data frames, keeping everything even if there’s no match.

-   **Example**:

-   *Left Table*: Attendance data from School A.

-   *Right Table*: Attendance data from School B.

-   *Result*: All students from both schools are included, with attendance data from each school aligned where available.

------------------------------------------------------------------------

**5. Semi Join**

-   **Scenario**: Filtering employees who completed a mandatory training session.

-   **Why Use It?**: You only want rows from the first data frame that have a match in the second.

-   **Example**:

-   *Left Table*: Employee details (e.g., name, department).

-   *Right Table*: Training completion records with employee IDs.

-   *Result*: Only employees who completed the training are included in the result.

------------------------------------------------------------------------

**6. Anti Join**

-   **Scenario**: Identifying customers who haven’t placed an order.

-   **Why Use It?**: You want rows from the first data frame that do not have a match in the second.

-   **Example**:

-   *Left Table*: Customer details with IDs.

-   *Right Table*: Order records with customer IDs.

-   *Result*: Only customers who haven’t placed any orders are included in the result.

------------------------------------------------------------------------

**Back from Digression**

**Q14.** Which join function would be the most efficient to join `mj_df` and `divisions_df`?


```{r}
## Join The Data Frame
```

#### Learning Moment 2 - Pivots (Another Digression)

Create sample Data Frames for the following examples:


```{r}
# # Sample Wide Data Frame
# wide_df <- ___________(
#   Name = c("Alice", "Bob", "Charlie"),
#   Math = c(90, 85, 78),
#   Science = c(88, 92, 81)
# )
# # Long-format Data Frame
# long_df <- ___________(
#   Student = c("Alice", "Alice", "Alice", 
#               "Bob", "Bob", "Bob", 
#               "Charlie", "Charlie", "Charlie"),
#   Subject = c("Math", "Science", "History", 
#               "Math", "Science", "History", 
#               "Math", "Science", "History"),
#   Score = c(88, 92, 85, 
#             79, 85, 80, 
#             91, 94, 89)
# )

```

##### Pivot Longer



```{r}
## Use Pivot Longer on wide_df
```

**Q15.** What is the purpose of the `pivot_longer` function?

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q16.** When pivoting a data frame to a longer format, what columns serve as the keys and what columns contain the values? Explain how this distinction helps structure the data for analysis.

\[Place Solution - Begin\]



\[Place Solution - End\]

##### Pivot Wider


```{r}
## Use Pivot Wider on long_df
```



**Q17.** What is the purpose of the `pivot_wider` function?

\[Place Solution - Begin\]



\[Place Solution - End\]


**Q18.** Based on the transformation, explain how the resulting wider_df structure differs from the original long_df. Include details about the number of rows, columns, and how the data is organized in your explanation.

\[Place Solution - Begin\]



\[Place Solution - End\]





**Q19.** Again look at this gif for more understanding. What do you notice?

![Tidyexpalin animation by Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain/raw/main/images/tidyr-pivoting.gif)

\[Place Solution - Begin\]



\[Place Solution - End\]

**Q20.** Which type of pivot would be most appropriate to analyze trends over time, such as comparing different variables like points, rebounds, and assists across MJ’s 15 seasons?



```{r}
# Pivot mod_1_mj_df 
```



#### Sub Task 1: Create Stage Variable

Create a new variable, Stage, that categorizes MJ's career into three distinct phases based on his playing seasons. The first five seasons (1–5) are labeled as "Early Career," the next five seasons (6–10) are categorized as "Intermediate," and the final five seasons (11–15) are labeled as "Veteran." This grouping allows for a clear analysis of MJ's performance trends and evolution throughout his career, making it easier to compare his contributions during different stages of his playing years.



```{r}
## Begin Work Here
```

#### Sub Task 2: Create a Summary Table

To analyze MJ's performance across divisions and stages of his career effectively, create a summary table that calculates his average points (`PTS`), total rebounds (`TRB`), and assists (`AST`) for each division during different stages of his career. Then, group the data by division and stage. Use `summarise` to calculate the average performance metrics for each combination of division and stage. Finally, restructure the table using `pivot_longer`. By organizing the performance metrics (`PTS`, `TRB`, `AST`) into a single column, the table becomes more flexible for detailed analysis, easier to filter or focus on specific metrics, and ideal for creating visualizations that compare trends across divisions and stages. This format simplifies identifying patterns and highlights differences in performance over time.



```{r}
## Begin Work Here
```

### Visualization

#### Sub Task 3: Perform an Analysis

Explore MJ's performance trends across the three career stages—Early Career, Intermediate, and Veteran—by focusing on his scoring (`PTS`) and minutes played (`MP`). Specifically, identify the division within each stage where MJ scored the highest total points. After determining the divisions with peak scoring performances, examine the relationship between `PTS` and `MP` for games played in these divisions during the respective stages. This analysis highlights patterns in MJ's workload and scoring efficiency and provides insights into divisions where he consistently excelled. Consider the competitiveness of the divisions and notable match-ups during these peak performances. The final visualization provides a detailed comparison of `PTS` and `MP` across these divisions and career stages, showcasing how MJ's role and performance evolved over time.



```{r}
## Begin Work Here - Transformation
```

```{r}
## Begin Work Here - Visualization
```

## Recap
